diff --git a/src/main.c b/src/main.c
index 3fc1a0c..1328b5a 100644
--- a/src/main.c
+++ b/src/main.c
@@ -119,6 +119,7 @@ char *cf_auth_dbname;
 
 int cf_max_client_conn;
 int cf_default_pool_size;
+usec_t cf_polling_frequency;
 int cf_min_pool_size;
 int cf_res_pool_size;
 usec_t cf_res_pool_timeout;
@@ -130,6 +131,7 @@ int cf_server_reset_query_always;
 char *cf_server_check_query;
 usec_t cf_server_check_delay;
 int cf_server_fast_close;
+usec_t cf_server_failed_delay;
 int cf_server_round_robin;
 int cf_disable_pqexec;
 usec_t cf_dns_max_ttl;
@@ -231,7 +233,7 @@ const struct CfLookup sslmode_map[] = {
 static const struct CfKey bouncer_params [] = {
 CF_ABS("admin_users", CF_STR, cf_admin_users, 0, ""),
 CF_ABS("application_name_add_host", CF_INT, cf_application_name_add_host, 0, "0"),
-CF_ABS("auth_dbname", CF_STR, cf_auth_dbname, 0, NULL),
+CF_ABS("auth_dbname", CF_AUTHDB, cf_auth_dbname, 0, NULL),
 CF_ABS("auth_file", CF_STR, cf_auth_file, 0, NULL),
 CF_ABS("auth_hba_file", CF_STR, cf_auth_hba_file, 0, ""),
 CF_ABS("auth_query", CF_STR, cf_auth_query, 0, "SELECT usename, passwd FROM pg_shadow WHERE usename=$1"),
@@ -273,6 +275,8 @@ CF_ABS("min_pool_size", CF_INT, cf_min_pool_size, 0, "0"),
 CF_ABS("peer_id", CF_INT, cf_peer_id, 0, "0"),
 CF_ABS("pidfile", CF_STR, cf_pidfile, CF_NO_RELOAD, ""),
 CF_ABS("pkt_buf", CF_INT, cf_sbuf_len, CF_NO_RELOAD, "4096"),
+// in seconds. maps to 100ms by default.
+CF_ABS("polling_frequency", CF_TIME_USEC, cf_polling_frequency, 0, ".1"),
 CF_ABS("pool_mode", CF_LOOKUP(pool_mode_map), cf_pool_mode, 0, "session"),
 CF_ABS("query_timeout", CF_TIME_USEC, cf_query_timeout, 0, "0"),
 CF_ABS("query_wait_timeout", CF_TIME_USEC, cf_query_wait_timeout, 0, "120"),
@@ -285,6 +289,8 @@ CF_ABS("server_check_delay", CF_TIME_USEC, cf_server_check_delay, 0, "30"),
 CF_ABS("server_check_query", CF_STR, cf_server_check_query, 0, "select 1"),
 CF_ABS("server_connect_timeout", CF_TIME_USEC, cf_server_connect_timeout, 0, "15"),
 CF_ABS("server_fast_close", CF_INT, cf_server_fast_close, 0, "0"),
+// allow backing off after switchover/failover. The delay to wait until reopening failed connections.
+CF_ABS("server_failed_delay", CF_TIME_USEC, cf_server_failed_delay, 0, "30"),
 CF_ABS("server_idle_timeout", CF_TIME_USEC, cf_server_idle_timeout, 0, "600"),
 CF_ABS("server_lifetime", CF_TIME_USEC, cf_server_lifetime, 0, "3600"),
 CF_ABS("server_login_retry", CF_TIME_USEC, cf_server_login_retry, 0, "15"),
@@ -1040,12 +1046,16 @@ int main(int argc, char *argv[])
 	}
 
 	write_pidfile();
+	if (fast_switchover)
+		run_once_to_init();
 
 	log_info("process up: %s, libevent %s (%s), adns: %s, tls: %s", PACKAGE_STRING,
 		 event_get_version(), event_base_get_method(pgb_event_base), adns_get_backend(),
 		 tls_backend_version());
 
 	sd_notify(0, "READY=1");
+	if (fast_switchover)
+		cf_server_check_delay = 0;
 
 	/* main loop */
 	while (cf_shutdown < 2)
